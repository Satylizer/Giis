# Отчет по 3D-редактору куба

## Общее описание
Этот проект реализует простой 3D-редактор для визуализации и трансформации куба. Программа написана на Python с использованием библиотеки `pygame` и поддерживает основные операции с 3D-объектами: вращение, масштабирование, отражение, а также перспективную и ортографическую проекции.

---

## Функциональные возможности

### Основные функции
- **Визуализация куба** с возможностью отображения:
  - Индексов вершин.
  - Координат вершин до проекции.
- **Трансформации**:
  - Вращение вокруг осей X, Y, Z.
  - Масштабирование по всем осям или только по оси X.
  - Отражение относительно плоскостей XY, XZ, YZ.
- **Проекции**:
  - Перспективная проекция (с параметром `d`).
  - Ортографическая проекция.
- **Загрузка/сохранение модели**:
  - Возможность загрузить вершины куба из файла.
  - Сохранить текущее состояние куба в файл.

---

## Архитектура программы

### Структура основного цикла
Программа использует главный цикл обработки событий `pygame`, который выполняется до тех пор, пока пользователь не закроет окно или не нажмет `ESC`.

#### Основные этапы работы:
1. **Инициализация**: создание окна, загрузка шрифтов, настройка начального состояния куба.
2. **Обработка событий**: клавиатурные команды для управления кубом.
3. **Рендеринг**: отрисовка куба, текстовой информации и статуса.
4. **Обновление экрана**: обновление изображения с частотой 60 FPS.

---

## Технические детали

### Цветовая палитра
```python
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
MAGENTA = (255, 0, 255)
```

### Настройки
- Размер экрана: `900x700`.
- Цвета текста:
  - Зелёный — для справочной информации.
  - Жёлтый — для координат.
  - Маджента — для индексов вершин.

### Начальные данные
Куб представлен следующими вершинами (в 3D-пространстве):
```python
initial_cube_vertices_3d = np.array([
    [-0.5, -0.5, -0.5], [ 0.5, -0.5, -0.5], [ 0.5,  0.5, -0.5], [-0.5,  0.5, -0.5],
    [-0.5, -0.5,  0.5], [ 0.5, -0.5,  0.5], [ 0.5,  0.5,  0.5], [-0.5,  0.5,  0.5]
])
```
Связь между вершинами задается через ребра:
```python
cube_edges = [
    (0, 1), (1, 2), (2, 3), (3, 0), (4, 5), (5, 6), (6, 7), (7, 4),
    (0, 4), (1, 5), (2, 6), (3, 7)
]
```

---

## Реализованные матричные преобразования

### Матрицы трансформаций
1. **Матрица перемещения**:
   ```python
   def get_translation_matrix(dx, dy, dz):
       return np.array([[1,0,0,0], [0,1,0,0], [0,0,1,0], [dx,dy,dz,1]])
   ```

2. **Матрица масштабирования**:
   ```python
   def get_scaling_matrix(sx, sy, sz):
       return np.array([[sx,0,0,0], [0,sy,0,0], [0,0,sz,0], [0,0,0,1]])
   ```

3. **Матрицы вращения**:
   - Вращение вокруг оси X:
     ```python
     def get_rotation_x_matrix(angle_rad):
         c, s = math.cos(angle_rad), math.sin(angle_rad)
         return np.array([[1,0,0,0], [0,c,s,0], [0,-s,c,0], [0,0,0,1]])
     ```
   - Вращение вокруг оси Y:
     ```python
     def get_rotation_y_matrix(angle_rad):
         c, s = math.cos(angle_rad), math.sin(angle_rad)
         return np.array([[c,0,-s,0], [0,1,0,0], [s,0,c,0], [0,0,0,1]])
     ```
   - Вращение вокруг оси Z:
     ```python
     def get_rotation_z_matrix(angle_rad):
         c, s = math.cos(angle_rad), math.sin(angle_rad)
         return np.array([[c,s,0,0], [-s,c,0,0], [0,0,1,0], [0,0,0,1]])
     ```

4. **Проекционные матрицы**:
   - Перспективная проекция:
     ```python
     def get_perspective_projection_matrix(focal_length_d):
         d = focal_length_d
         if abs(d) < 1e-5: d = np.sign(d) * 1e-5 if d != 0 else 1e-5
         return np.array([[1,0,0,0], [0,1,0,0], [0,0,0,1/d], [0,0,0,1]])
     ```
   - Ортографическая проекция:
     ```python
     def get_orthographic_projection_matrix():
         return np.array([[1,0,0,0], [0,1,0,0], [0,0,0,0], [0,0,0,1]])
     ```

---

## Управление

### Клавиши
| Клавиша | Действие |
|--------|----------|
| `A/D` | Вращение по оси Y |
| `W/S` | Вращение по оси X |
| `Q/E` | Вращение по оси Z |
| `+/-` | Увеличение/уменьшение масштаба |
| `X` / `Shift+X` | Масштабирование только по оси X |
| `F1/F2/F3` | Отражение относительно плоскостей XY, XZ, YZ |
| `P` | Перспективная проекция |
| `O` | Ортографическая проекция |
| `R` | Сброс всех трансформаций |
| `I` | Показать/скрыть индексы вершин |
| `C` | Показать/скрыть координаты вершин |
| `L` | Загрузить модель из файла `cube_data.txt` |
| `K` | Сохранить текущее состояние в файл `cube_data.txt` |
| `H` | Показать/скрыть справку |

---

## Работа с файлами

### Формат данных
Файл содержит 8 строк, каждая из которых представляет собой координаты одной вершины куба:
```
x y z
```

### Функции работы с файлами
- `load_model_from_file(filename)` — загружает вершины куба из файла.
- `save_model_to_file(filename, vertices_3d_to_save)` — сохраняет текущее состояние куба в файл.

---

## Визуализация

### Отладочная информация
На экране отображается:
- Тип текущей проекции.
- Масштаб отображения.
- Информация о том, были ли применены трансформации.
- Индексы вершин.
- Координаты вершин до проекции.

---

## Возможности расширения
1. **Добавление новых объектов**: можно добавить поддержку других 3D-фигур (например, пирамиды, цилиндра).
2. **Улучшенная система загрузки/сохранения**: поддержка форматов `.obj` или `.stl`.
3. **Интерфейс пользователя**: добавление GUI для удобного управления трансформациями.
4. **Анимация**: автоматическое вращение или другие эффекты.

---

## Заключение
Проект представляет собой базовый 3D-редактор, демонстрирующий работу с матрицами преобразований и проекций. Он может быть полезен как учебный инструмент для изучения компьютерной графики и 3D-визуализации.

---


# Отчет по Лабораторным Работам: Часть 2 – Вычислительная геометрия и Заливка Полигонов

## Введение

Эта часть отчета описывает два проекта:
1.  **Простой Графический Редактор**: Реализация и визуализация базовых алгоритмов 2D вычислительной геометрии.
2.  **Алгоритмы Заливки Полигонов**: Реализация и сравнение различных методов заливки полигонов, включая построчные и затравочные алгоритмы, с возможностью пошаговой отладки.

## 1. Простой Графический Редактор (Вычислительная геометрия)

**Файл:** `project_computational_geometry.py` (второй скрипт в вашем запросе)

### 1.1. Цель работы

Создать интерактивное приложение для демонстрации и тестирования фундаментальных алгоритмов 2D вычислительной геометрии. Пользователь должен иметь возможность рисовать точки, линии и полигоны, а затем применять к ним различные геометрические операции.

### 1.2. Реализованные алгоритмы и функциональность

Приложение, созданное с использованием Tkinter, позволяет:

*   **Рисовать примитивы:**
    *   Полигоны (последовательностью кликов левой кнопкой мыши, завершение правой).
    *   Отрезки (двумя кликами левой кнопкой мыши).
*   **Проверять выпуклость полигона (`check_polygon_convexity`):**
    *   Определяет, является ли последний нарисованный полигон выпуклым (с указанием направления обхода – по или против часовой стрелки), вогнутым или вырожденным (коллинеарные вершины).
    *   **Логика:** Использует векторное (косое) произведение для последовательных пар ребер. Если знаки всех произведений одинаковы, полигон выпуклый. Если знаки разные – вогнутый. Нулевые произведения указывают на коллинеарность.
*   **Находить внутренние нормали полигона (`get_internal_normals`):**
    *   Для выпуклого полигона вычисляет и отображает нормали к каждому ребру, направленные внутрь полигона.
    *   **Логика:** Для каждого ребра (p1, p2) вектор ребра `(dx, dy) = (p2.x - p1.x, p2.y - p1.y)`. Нормаль (в зависимости от направления обхода для "внутренности") будет `(-dy, dx)` или `(dy, -dx)`, которая затем нормализуется.
*   **Строить выпуклую оболочку (`graham_scan`, `jarvis_march`):**
    *   Для всех нарисованных точек (вершин полигонов и концов отрезков) строит выпуклую оболочку.
    *   **Алгоритм Грэхема (`graham_scan`):**
        1.  Находит опорную точку (самую нижнюю, затем самую левую).
        2.  Сортирует остальные точки по полярному углу относительно опорной.
        3.  Проходит по отсортированным точкам, добавляя их в оболочку и удаляя предыдущие точки, если образуется "правый" поворот (не левый).
    *   **Алгоритм Джарвиса (Обход по подарочной упаковке) (`jarvis_march`):**
        1.  Находит стартовую точку (самую левую).
        2.  Итеративно находит следующую точку оболочки, которая образует самый "правый" (или наименьший полярный угол) поворот с текущей точкой оболочки относительно всех остальных точек.
        3.  Процесс повторяется, пока оболочка не замкнется.
*   **Находить пересечение отрезка с полигоном (`line_segment_intersects_polygon`):**
    *   Пользователь рисует отрезок, затем выбирается последний нарисованный полигон. Алгоритм находит и отображает все точки пересечения отрезка с ребрами полигона.
    *   **Логика:** Для каждой пары (тестовый отрезок, ребро полигона) решается система линейных уравнений для нахождения параметров `t` (для отрезка) и `u` (для ребра). Если `0 <= t <= 1` и `0 <= u <= 1`, то точка пересечения лежит на обоих сегментах.
*   **Проверять принадлежность точки полигону (`is_point_in_polygon`):**
    *   Пользователь выбирает точку кликом, затем выбирается последний нарисованный полигон. Алгоритм определяет, находится ли точка внутри, снаружи или на границе полигона.
    *   **Логика:** Используется метод трассировки луча (ray casting). Из тестовой точки выпускается луч в произвольном направлении (например, горизонтально вправо). Подсчитывается количество пересечений луча с ребрами полигона. Четное число – точка снаружи, нечетное – внутри. Особые случаи (попадание на вершину или ребро) обрабатываются.

### 1.3. Пользовательский интерфейс

*   **Холст (`tk.Canvas`):** Основная область для рисования и визуализации.
*   **Меню и Панель инструментов:** Предоставляют доступ ко всем функциям.
*   **Обратная связь:** Сообщения в строке состояния и диалоговые окна информируют пользователя о выбранном инструменте и результатах операций.
*   **Визуализация:**
    *   Полигоны и линии отображаются стандартными цветами.
    *   Выпуклые оболочки – пунктирной линией.
    *   Нормали – стрелками.
    *   Точки пересечения и тестовые точки – выделенными маркерами.

### 1.4. Возможные проблемы и наблюдения

*   **Точность вычислений:** При работе с числами с плавающей запятой (float) сравнения на точное равенство заменены проверками нахождения в пределах малого эпсилон (`1e-9`) для избежания ошибок округления.
*   **Коллинеарные точки:** Алгоритмы построения выпуклой оболочки (особенно Грэхема) требуют аккуратной обработки коллинеарных точек, чтобы избежать включения лишних точек или нарушения порядка обхода. В реализации Грэхема используется сортировка по расстоянию при равных углах и фильтрация для удаления точек, лежащих "внутри" коллинеарного сегмента.
*   **Обработка вырожденных случаев:** Например, полигон из двух точек или проверка пересечения с полигоном, у которого менее 3 вершин.

## 2. Алгоритмы Заливки Полигонов

**Файл:** `project_polygon_filling.py` (третий скрипт в вашем запросе)

### 2.1. Цель работы

Реализовать и визуализировать различные алгоритмы заливки многоугольников, включая построчные методы и методы с затравкой. Предоставить возможность пошаговой отладки для лучшего понимания работы алгоритмов.

### 2.2. Реализованные алгоритмы и функциональность

Приложение на Tkinter позволяет пользователю:

1.  **Нарисовать полигон:** Клик левой кнопкой мыши для добавления вершин. Кнопка "Finish Polygon" замыкает полигон. Границы полигона рисуются с использованием алгоритма Брезенхэма (`bresenham_line`) для точного определения пикселей границы (`boundary_pixels`).
2.  **Выбрать алгоритм заливки:**
    *   **Построчный алгоритм с упорядоченным списком ребер (`_scanline_ordered_edge_list_debug`):**
        *   **Логика:**
            1.  Создается список всех не горизонтальных ребер полигона.
            2.  Для каждой строки сканирования (scanline `y`) от `y_min` до `y_max` полигона:
                a. Находятся все точки пересечения активных ребер с текущей строкой сканирования.
                b. Точки пересечения по оси `x` сортируются.
                c. Промежутки между парами отсортированных `x`-координат закрашиваются.
        *   *Отличие от AEL:* Список ребер глобальный, пересечения ищутся каждый раз по всему списку.
    *   **Построчный алгоритм с активным списком ребер (AEL) (`_scanline_ael_debug`):**
        *   **Логика:**
            1.  **ET (Edge Table):** Создается таблица ребер, где для каждой строки `y` хранится список ребер, начинающихся на этой строке (`y_min`). Ребра хранят `y_max`, `x_current` (x-координата пересечения с текущей строкой `y`) и `1/m` (обратный наклон).
            2.  **AEL (Active Edge List):** Инициализируется пустым.
            3.  Для каждой строки сканирования `y`:
                a. Ребра, для которых `y_max <= y`, удаляются из AEL.
                b. Ребра из ET для текущей `y` добавляются в AEL.
                c. AEL сортируется по `x_current`.
                d. Промежутки между парами `x_current` в AEL закрашиваются.
                e. `x_current` для каждого ребра в AEL обновляется: `x_current += 1/m`.
    *   **Простой затравочный алгоритм (4-связный) (`_seed_fill_simple_debug`):**
        *   **Логика:**
            1.  Пользователь указывает затравочную точку (`seed_point`).
            2.  Точка помещается в стек.
            3.  Пока стек не пуст:
                a. Извлекается пиксель `(px, py)`.
                b. Если пиксель не является граничным, не выходит за пределы холста и еще не закрашен:
                    i.  Закрашиваем пиксель.
                    ii. Добавляем его 4-связных соседей (вверх, вниз, влево, вправо) в стек.
    *   **Построчный затравочный алгоритм (4-связный) (`_scanline_seed_fill_debug`):**
        *   **Логика:**
            1.  Пользователь указывает затравочную точку.
            2.  Точка помещается в стек.
            3.  Пока стек не пуст:
                a. Извлекается затравочная точка `(curr_x, curr_y)`.
                b. На текущей строке `curr_y` находится горизонтальный отрезок (span) пикселей, содержащий `(curr_x, curr_y)`, который не пересекает границу и не выходит за пределы. Этот отрезок (от `x_left` до `x_right`) закрашивается.
                c. На строках `curr_y - 1` и `curr_y + 1` в пределах `[x_left, x_right]` ищутся новые затравочные пиксели (начало новых непрерывных отрезков, которые можно закрасить). Найденные новые затравочные пиксели добавляются в стек.
3.  **Запустить заливку:** Сразу или в режиме пошаговой отладки.
4.  **Пошаговая отладка:** Кнопка "Next Step" выполняет один логический шаг алгоритма. Информация о текущем шаге выводится в текстовое поле.

### 2.3. Пользовательский интерфейс

*   **Холст (`tk.Canvas`):** Для рисования полигона и отображения процесса заливки.
*   **Панель управления:**
    *   Радиокнопки для выбора алгоритма.
    *   Кнопки "Draw Polygon", "Finish Polygon", "Fill Polygon".
    *   Флажок "Debug Mode".
    *   Кнопка "Next Step" (активна в режиме отладки).
    *   Кнопка "Clear All".
*   **Область отладочной информации (`scrolledtext.ScrolledText`):** Показывает детали текущего шага алгоритма.
*   **Строка состояния:** Информирует о текущем режиме или результате операции.
*   **Визуализация отладки:**
    *   Текущая строка сканирования (для построчных алгоритмов).
    *   Точки пересечения, активные пиксели в стеке.
    *   Закрашиваемые пиксели/отрезки.

### 2.4. Особенности реализации и наблюдения

*   **`PIXEL_SIZE`:** Используется для симуляции пиксельной графики на холсте Tkinter. Все координаты и размеры привязываются к этому значению.
*   **Определение границы (`boundary_pixels`):** Пиксели, составляющие ребра полигона, точно определяются с помощью `bresenham_line` и хранятся в множестве. Это важно для корректной работы затравочных алгоритмов (чтобы не "просочиться" через границу) и для избежания закрашивания самой границы.
*   **Обработка особых случаев в построчных алгоритмах:**
    *   Горизонтальные ребра игнорируются при построении ET/списка ребер, так как они не создают пересечений, изменяющих четность внутри/снаружи.
    *   Вершины, лежащие на строке сканирования: корректная обработка (например, считать вершину как одно или два пересечения в зависимости от расположения смежных ребер) важна, но в данной реализации упрощена за счет сортировки X-координат пересечений.
*   **Эффективность:**
    *   Простой затравочный алгоритм может привести к переполнению стека для больших областей из-за рекурсивного характера добавления соседей.
    *   Построчный затравочный алгоритм более эффективен по памяти, так как обрабатывает целые отрезки за раз.
    *   AEL обычно эффективнее простого построчного алгоритма с полным списком ребер, так как работает только с "активными" на данный момент ребрами.

## 3. Общее заключение по Части 2

В рамках этой части были успешно реализованы и изучены ключевые концепции 2D вычислительной геометрии и алгоритмов заливки.

*   **Проект по вычислительной геометрии** позволил наглядно продемонстрировать работу алгоритмов определения выпуклости, построения выпуклых оболочек, поиска пересечений и определения принадлежности точки полигону. Интерактивный характер приложения способствует лучшему пониманию их логики и краевых случаев.
*   **Проект по алгоритмам заливки** предоставил платформу для сравнения различных подходов к заполнению полигонов. Особенно ценной является возможность пошаговой отладки, которая детализирует внутреннюю работу каждого алгоритма, выявляя их сильные и слабые стороны в различных ситуациях.

Оба проекта служат хорошей основой для дальнейшего изучения более сложных алгоритмов компьютерной графики и геометрического моделирования.

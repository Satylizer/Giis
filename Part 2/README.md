# Отчет по Лабораторным Работам: Часть 2 – Вычислительная геометрия и Заливка Полигонов

## Введение

Эта часть отчета описывает два проекта:
1.  **Простой Графический Редактор**: Реализация и визуализация базовых алгоритмов 2D вычислительной геометрии.
2.  **Алгоритмы Заливки Полигонов**: Реализация и сравнение различных методов заливки полигонов, включая построчные и затравочные алгоритмы, с возможностью пошаговой отладки.

## 1. Простой Графический Редактор (Вычислительная геометрия)

**Файл:** `project_computational_geometry.py` (второй скрипт в вашем запросе)

### 1.1. Цель работы

Создать интерактивное приложение для демонстрации и тестирования фундаментальных алгоритмов 2D вычислительной геометрии. Пользователь должен иметь возможность рисовать точки, линии и полигоны, а затем применять к ним различные геометрические операции.

### 1.2. Реализованные алгоритмы и функциональность

Приложение, созданное с использованием Tkinter, позволяет:

*   **Рисовать примитивы:**
    *   Полигоны (последовательностью кликов левой кнопкой мыши, завершение правой).
    *   Отрезки (двумя кликами левой кнопкой мыши).
*   **Проверять выпуклость полигона (`check_polygon_convexity`):**
    *   Определяет, является ли последний нарисованный полигон выпуклым (с указанием направления обхода – по или против часовой стрелки), вогнутым или вырожденным (коллинеарные вершины).
    *   **Логика:** Использует векторное (косое) произведение для последовательных пар ребер. Если знаки всех произведений одинаковы, полигон выпуклый. Если знаки разные – вогнутый. Нулевые произведения указывают на коллинеарность.
*   **Находить внутренние нормали полигона (`get_internal_normals`):**
    *   Для выпуклого полигона вычисляет и отображает нормали к каждому ребру, направленные внутрь полигона.
    *   **Логика:** Для каждого ребра (p1, p2) вектор ребра `(dx, dy) = (p2.x - p1.x, p2.y - p1.y)`. Нормаль (в зависимости от направления обхода для "внутренности") будет `(-dy, dx)` или `(dy, -dx)`, которая затем нормализуется.
*   **Строить выпуклую оболочку (`graham_scan`, `jarvis_march`):**
    *   Для всех нарисованных точек (вершин полигонов и концов отрезков) строит выпуклую оболочку.
    *   **Алгоритм Грэхема (`graham_scan`):**
        1.  Находит опорную точку (самую нижнюю, затем самую левую).
        2.  Сортирует остальные точки по полярному углу относительно опорной.
        3.  Проходит по отсортированным точкам, добавляя их в оболочку и удаляя предыдущие точки, если образуется "правый" поворот (не левый).
    *   **Алгоритм Джарвиса (Обход по подарочной упаковке) (`jarvis_march`):**
        1.  Находит стартовую точку (самую левую).
        2.  Итеративно находит следующую точку оболочки, которая образует самый "правый" (или наименьший полярный угол) поворот с текущей точкой оболочки относительно всех остальных точек.
        3.  Процесс повторяется, пока оболочка не замкнется.
*   **Находить пересечение отрезка с полигоном (`line_segment_intersects_polygon`):**
    *   Пользователь рисует отрезок, затем выбирается последний нарисованный полигон. Алгоритм находит и отображает все точки пересечения отрезка с ребрами полигона.
    *   **Логика:** Для каждой пары (тестовый отрезок, ребро полигона) решается система линейных уравнений для нахождения параметров `t` (для отрезка) и `u` (для ребра). Если `0 <= t <= 1` и `0 <= u <= 1`, то точка пересечения лежит на обоих сегментах.
*   **Проверять принадлежность точки полигону (`is_point_in_polygon`):**
    *   Пользователь выбирает точку кликом, затем выбирается последний нарисованный полигон. Алгоритм определяет, находится ли точка внутри, снаружи или на границе полигона.
    *   **Логика:** Используется метод трассировки луча (ray casting). Из тестовой точки выпускается луч в произвольном направлении (например, горизонтально вправо). Подсчитывается количество пересечений луча с ребрами полигона. Четное число – точка снаружи, нечетное – внутри. Особые случаи (попадание на вершину или ребро) обрабатываются.

### 1.3. Пользовательский интерфейс

*   **Холст (`tk.Canvas`):** Основная область для рисования и визуализации.
*   **Меню и Панель инструментов:** Предоставляют доступ ко всем функциям.
*   **Обратная связь:** Сообщения в строке состояния и диалоговые окна информируют пользователя о выбранном инструменте и результатах операций.
*   **Визуализация:**
    *   Полигоны и линии отображаются стандартными цветами.
    *   Выпуклые оболочки – пунктирной линией.
    *   Нормали – стрелками.
    *   Точки пересечения и тестовые точки – выделенными маркерами.

### 1.4. Возможные проблемы и наблюдения

*   **Точность вычислений:** При работе с числами с плавающей запятой (float) сравнения на точное равенство заменены проверками нахождения в пределах малого эпсилон (`1e-9`) для избежания ошибок округления.
*   **Коллинеарные точки:** Алгоритмы построения выпуклой оболочки (особенно Грэхема) требуют аккуратной обработки коллинеарных точек, чтобы избежать включения лишних точек или нарушения порядка обхода. В реализации Грэхема используется сортировка по расстоянию при равных углах и фильтрация для удаления точек, лежащих "внутри" коллинеарного сегмента.
*   **Обработка вырожденных случаев:** Например, полигон из двух точек или проверка пересечения с полигоном, у которого менее 3 вершин.

## 2. Алгоритмы Заливки Полигонов

**Файл:** `project_polygon_filling.py` (третий скрипт в вашем запросе)

### 2.1. Цель работы

Реализовать и визуализировать различные алгоритмы заливки многоугольников, включая построчные методы и методы с затравкой. Предоставить возможность пошаговой отладки для лучшего понимания работы алгоритмов.

### 2.2. Реализованные алгоритмы и функциональность

Приложение на Tkinter позволяет пользователю:

1.  **Нарисовать полигон:** Клик левой кнопкой мыши для добавления вершин. Кнопка "Finish Polygon" замыкает полигон. Границы полигона рисуются с использованием алгоритма Брезенхэма (`bresenham_line`) для точного определения пикселей границы (`boundary_pixels`).
2.  **Выбрать алгоритм заливки:**
    *   **Построчный алгоритм с упорядоченным списком ребер (`_scanline_ordered_edge_list_debug`):**
        *   **Логика:**
            1.  Создается список всех не горизонтальных ребер полигона.
            2.  Для каждой строки сканирования (scanline `y`) от `y_min` до `y_max` полигона:
                a. Находятся все точки пересечения активных ребер с текущей строкой сканирования.
                b. Точки пересечения по оси `x` сортируются.
                c. Промежутки между парами отсортированных `x`-координат закрашиваются.
        *   *Отличие от AEL:* Список ребер глобальный, пересечения ищутся каждый раз по всему списку.
    *   **Построчный алгоритм с активным списком ребер (AEL) (`_scanline_ael_debug`):**
        *   **Логика:**
            1.  **ET (Edge Table):** Создается таблица ребер, где для каждой строки `y` хранится список ребер, начинающихся на этой строке (`y_min`). Ребра хранят `y_max`, `x_current` (x-координата пересечения с текущей строкой `y`) и `1/m` (обратный наклон).
            2.  **AEL (Active Edge List):** Инициализируется пустым.
            3.  Для каждой строки сканирования `y`:
                a. Ребра, для которых `y_max <= y`, удаляются из AEL.
                b. Ребра из ET для текущей `y` добавляются в AEL.
                c. AEL сортируется по `x_current`.
                d. Промежутки между парами `x_current` в AEL закрашиваются.
                e. `x_current` для каждого ребра в AEL обновляется: `x_current += 1/m`.
    *   **Простой затравочный алгоритм (4-связный) (`_seed_fill_simple_debug`):**
        *   **Логика:**
            1.  Пользователь указывает затравочную точку (`seed_point`).
            2.  Точка помещается в стек.
            3.  Пока стек не пуст:
                a. Извлекается пиксель `(px, py)`.
                b. Если пиксель не является граничным, не выходит за пределы холста и еще не закрашен:
                    i.  Закрашиваем пиксель.
                    ii. Добавляем его 4-связных соседей (вверх, вниз, влево, вправо) в стек.
    *   **Построчный затравочный алгоритм (4-связный) (`_scanline_seed_fill_debug`):**
        *   **Логика:**
            1.  Пользователь указывает затравочную точку.
            2.  Точка помещается в стек.
            3.  Пока стек не пуст:
                a. Извлекается затравочная точка `(curr_x, curr_y)`.
                b. На текущей строке `curr_y` находится горизонтальный отрезок (span) пикселей, содержащий `(curr_x, curr_y)`, который не пересекает границу и не выходит за пределы. Этот отрезок (от `x_left` до `x_right`) закрашивается.
                c. На строках `curr_y - 1` и `curr_y + 1` в пределах `[x_left, x_right]` ищутся новые затравочные пиксели (начало новых непрерывных отрезков, которые можно закрасить). Найденные новые затравочные пиксели добавляются в стек.
3.  **Запустить заливку:** Сразу или в режиме пошаговой отладки.
4.  **Пошаговая отладка:** Кнопка "Next Step" выполняет один логический шаг алгоритма. Информация о текущем шаге выводится в текстовое поле.

### 2.3. Пользовательский интерфейс

*   **Холст (`tk.Canvas`):** Для рисования полигона и отображения процесса заливки.
*   **Панель управления:**
    *   Радиокнопки для выбора алгоритма.
    *   Кнопки "Draw Polygon", "Finish Polygon", "Fill Polygon".
    *   Флажок "Debug Mode".
    *   Кнопка "Next Step" (активна в режиме отладки).
    *   Кнопка "Clear All".
*   **Область отладочной информации (`scrolledtext.ScrolledText`):** Показывает детали текущего шага алгоритма.
*   **Строка состояния:** Информирует о текущем режиме или результате операции.
*   **Визуализация отладки:**
    *   Текущая строка сканирования (для построчных алгоритмов).
    *   Точки пересечения, активные пиксели в стеке.
    *   Закрашиваемые пиксели/отрезки.

### 2.4. Особенности реализации и наблюдения

*   **`PIXEL_SIZE`:** Используется для симуляции пиксельной графики на холсте Tkinter. Все координаты и размеры привязываются к этому значению.
*   **Определение границы (`boundary_pixels`):** Пиксели, составляющие ребра полигона, точно определяются с помощью `bresenham_line` и хранятся в множестве. Это важно для корректной работы затравочных алгоритмов (чтобы не "просочиться" через границу) и для избежания закрашивания самой границы.
*   **Обработка особых случаев в построчных алгоритмах:**
    *   Горизонтальные ребра игнорируются при построении ET/списка ребер, так как они не создают пересечений, изменяющих четность внутри/снаружи.
    *   Вершины, лежащие на строке сканирования: корректная обработка (например, считать вершину как одно или два пересечения в зависимости от расположения смежных ребер) важна, но в данной реализации упрощена за счет сортировки X-координат пересечений.
*   **Эффективность:**
    *   Простой затравочный алгоритм может привести к переполнению стека для больших областей из-за рекурсивного характера добавления соседей.
    *   Построчный затравочный алгоритм более эффективен по памяти, так как обрабатывает целые отрезки за раз.
    *   AEL обычно эффективнее простого построчного алгоритма с полным списком ребер, так как работает только с "активными" на данный момент ребрами.

## 3. Общее заключение по Части 2

В рамках этой части были успешно реализованы и изучены ключевые концепции 2D вычислительной геометрии и алгоритмов заливки.

*   **Проект по вычислительной геометрии** позволил наглядно продемонстрировать работу алгоритмов определения выпуклости, построения выпуклых оболочек, поиска пересечений и определения принадлежности точки полигону. Интерактивный характер приложения способствует лучшему пониманию их логики и краевых случаев.
*   **Проект по алгоритмам заливки** предоставил платформу для сравнения различных подходов к заполнению полигонов. Особенно ценной является возможность пошаговой отладки, которая детализирует внутреннюю работу каждого алгоритма, выявляя их сильные и слабые стороны в различных ситуациях.

Оба проекта служат хорошей основой для дальнейшего изучения более сложных алгоритмов компьютерной графики и геометрического моделирования.
